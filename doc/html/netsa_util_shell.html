<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>netsa.util.shell — Robust Shell Pipelines &mdash; NetSA Python v0.9 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="NetSA Python v0.9 documentation" href="index.html" />
    <link rel="next" title="Data Manipulation" href="netsa_data.html" />
    <link rel="prev" title="netsa.sql — SQL Database Access" href="netsa_sql.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="netsa_data.html" title="Data Manipulation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="netsa_sql.html" title="netsa.sql — SQL Database Access"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">NetSA Python v0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-netsa.util.shell">
<h1><tt class="xref docutils literal"><span class="pre">netsa.util.shell</span></tt> &#8212; Robust Shell Pipelines<a class="headerlink" href="#module-netsa.util.shell" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref docutils literal"><span class="pre">netsa.util.shell</span></tt> module provides a facility for securely
and efficiently running UNIX command pipelines from Python.  To avoid
text substitution attacks, it does not actually use the UNIX shell to
process commands.  In addition, it runs commands directly in a way
that allows easier clean-up in the case of errors.</p>
<p>The following standard Python library functions provide similar
capabilities, but without either sufficient text substitution
protections or sufficient error-checking and recovery mechanisms:</p>
<blockquote>
<ul class="simple">
<li>The <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/os.html#os.system"><tt class="xref docutils literal"><span class="pre">os.system</span></tt></a> function</li>
<li>The <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/subprocess.html#module-subprocess"><tt class="xref docutils literal"><span class="pre">subprocess</span></tt></a> module</li>
<li>The <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/popen2.html#module-popen2"><tt class="xref docutils literal"><span class="pre">popen2</span></tt></a> module</li>
</ul>
</blockquote>
<p>Here are some examples, in increasing complexity, of the use of the
<a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> and <a title="netsa.util.shell.run_collect" class="reference internal" href="#netsa.util.shell.run_collect"><tt class="xref docutils literal"><span class="pre">run_collect</span></tt></a> functions:</p>
<p>Run a single process and wait for it to complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: rm -rf /tmp/test</span>
<span class="n">run_parallel</span><span class="p">(</span><span class="s">&quot;rm -rf /tmp/test&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Start two processes and wait for both to complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: rm -rf /tmp/test1 &amp; rm -rf /tmp/test2 &amp; wait</span>
<span class="n">run_parallel</span><span class="p">(</span><span class="s">&quot;rm -rf /tmp/test_dir_1&quot;</span><span class="p">,</span>
             <span class="s">&quot;rm -rf /tmp/test_dir_2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Store the output of a command into a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: echo test &gt; /tmp/testout</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="s">&quot;echo test&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Read the input of a command from a file (and put the ouput into
another file):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: cat &lt; /tmp/test &gt; /tmp/testout</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="s">&quot;&lt;/tmp/test&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Append the output of a command to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: echo test &gt;&gt; /tmp/testout</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="s">&quot;echo test&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Pipe the output of one command into another command (and put the
output into a file):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: echo test | sed &#39;s/e/f/&#39; &gt; /tmp/testout</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="s">&quot;echo test&quot;</span><span class="p">,</span> <span class="s">&quot;sed &#39;s/e/f/&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Run two pipelines in parallel and wait for both to complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell:</span>
<span class="c">#    echo test | sed &#39;s/e/f/&#39; &gt; /tmp/testout &amp;</span>
<span class="c">#    cat /etc/passwd | cut -f1 -d&#39;|&#39; &gt; /tmp/testout2 &amp;</span>
<span class="c">#    wait</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="s">&quot;echo test&quot;</span><span class="p">,</span> <span class="s">&quot;sed &#39;s/e/f/&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s">&quot;cat /etc/passwd&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f1 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Run a single pipeline and collect the output and error output in the
variables <em>out</em> and <em>err</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: foo=`cat /etc/passwd | cut -f1 -d&#39;|&#39;`</span>
<span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">foo_err</span><span class="p">)</span> <span class="o">=</span> <span class="n">run_collect</span><span class="p">(</span><span class="s">&quot;cat /etc/passwd&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f1 -d&#39;|&#39;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following examples are more complicated, and require the use of
the long forms of <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> and <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a> specifications.
(All of the examples above have used the short-hand forms.)  You
should read the documentation for <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> and <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a>
to see how the long forms and short-hand forms are related.</p>
<p>Run a pipeline, collect standard output of the pipeline to one file,
and append standard error from all of the commands to another file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: ( gen-data | cut -f1 -d&#39;|&#39; &gt; /tmp/testout ) 2&gt;&gt; /tmp/testlog</span>
<span class="n">run_parallel</span><span class="p">(</span><span class="n">pipeline</span><span class="p">(</span><span class="s">&quot;gen-data&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f1 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">,</span>
                      <span class="n">stderr</span><span class="o">=</span><span class="s">&quot;/tmp/testlog&quot;</span><span class="p">,</span> <span class="n">stderr_append</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p>Run a pipeline, collect standard output of the pipeline to one file,
and collect standard error from one command to another file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: ( gen-data 2&gt; /tmp/testlog ) | cut -f1 -d&#39;|&#39; &gt; /tmp/testout</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="n">command</span><span class="p">(</span><span class="s">&quot;gen-data&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="s">&quot;/tmp/testlog&quot;</span><span class="p">),</span>
              <span class="s">&quot;cut -f1 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Run a pipeline, collect standard output of the pipeline to a file, and
ignore the potentially non-zero exit status of the <tt class="docutils literal"><span class="pre">gen-data</span></tt>
command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell: (gen-data | cut -f1 -d&#39;|&#39; &gt; /tmp/testout) || true</span>
<span class="n">run_parallel</span><span class="p">([</span><span class="n">command</span><span class="p">(</span><span class="s">&quot;gen-data&quot;</span><span class="p">,</span> <span class="n">ignore_exit_status</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
              <span class="s">&quot;cut -f1 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Use long pipelines to process data using multiple named pipes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Shell:</span>
<span class="c">#   mkfifo /tmp/fifo1</span>
<span class="c">#   mkfifo /tmp/fifo2</span>
<span class="c">#   tee /tmp/fifo1 &lt; /etc/passwd | cut -f1 -d&#39;|&#39; | sort &gt; /tmp/out1 &amp;</span>
<span class="c">#   tee /tmp/fifo2 &lt; /tmp/fifo1 | cut -f2 -d&#39;|&#39; | sort &gt; /tmp/out2 &amp;</span>
<span class="c">#   cut -f3 -d&#39;|&#39; &lt; /tmp/fifo2 | sort | uniq -c &gt; /tmp/out3 &amp;</span>
<span class="c">#   wait</span>
<span class="n">run_parallel</span><span class="p">(</span><span class="s">&quot;mkfifo /tmp/fifo1&quot;</span><span class="p">,</span>
             <span class="s">&quot;mkfifo /tmp/fifo2&quot;</span><span class="p">)</span>
<span class="n">run_parallel</span><span class="p">(</span>
    <span class="p">[</span><span class="s">&quot;&lt;/etc/passwd&quot;</span><span class="p">,</span> <span class="s">&quot;tee /tmp/fifo1&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f1 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/out1&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s">&quot;&lt;/tmp/fifo1&quot;</span><span class="p">,</span> <span class="s">&quot;tee /tmp/fifo2&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f2 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/out2&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s">&quot;&lt;/tmp/fifo2&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f3 -d&#39;|&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;sort&quot;</span><span class="p">,</span> <span class="s">&quot;uniq -c&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;/tmp/out3&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="netsa.util.shell.PipelineException">
<em class="property">exception </em><tt class="descclassname">netsa.util.shell.</tt><tt class="descname">PipelineException</tt><big>(</big><em>message</em>, <em>exit_statuses</em><big>)</big><a class="headerlink" href="#netsa.util.shell.PipelineException" title="Permalink to this definition">¶</a></dt>
<dd>This exception represents a failure to process a pipeline in
either <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> or <a title="netsa.util.shell.run_collect" class="reference internal" href="#netsa.util.shell.run_collect"><tt class="xref docutils literal"><span class="pre">run_collect</span></tt></a>.  It can be
triggered by any of the commands being run by the function failing
(either because the file was not found or because the command&#8217;s
exit status was unacceptable.)  The message contains a summary of
the status of all of the sub-commands at the time the problem was
discovered, including stderr output for each sub-command if
available.</dd></dl>

</div>
<div class="section" id="building-commands-and-pipelines">
<h2>Building Commands and Pipelines<a class="headerlink" href="#building-commands-and-pipelines" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="netsa.util.shell.command">
<tt class="descclassname">netsa.util.shell.</tt><tt class="descname">command</tt><big>(</big><em>&lt;command spec&gt;</em><span class="optional">[</span>, <em>stderr : str or file</em>, <em>stderr_append=False</em>, <em>ignore_exit_status=False</em>, <em>ignore_exit_statuses : int seq</em><span class="optional">]</span><big>)</big> &rarr; command<a class="headerlink" href="#netsa.util.shell.command" title="Permalink to this definition">¶</a></dt>
<dd><p>Interprets the arguments as a &#8220;command specification&#8221;, and returns
that specification as a value.</p>
<p>If there is only a single argument and it is a <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a>,
then a new command is returned with the options provided by this
call.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_command</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="n">old_command</span><span class="p">,</span> <span class="n">ignore_exit_status</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is only a single argument and it is a <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str</span></tt></a>, the
string is parsed as if it were a simple shell command.
(i.e. respecting single and double quotation marks, backslashes,
etc.)  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_command</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="s">&quot;ls /etc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is only a single argument and it is a <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#list"><tt class="xref docutils literal"><span class="pre">list</span></tt></a> or a
<a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#tuple"><tt class="xref docutils literal"><span class="pre">tuple</span></tt></a>, interpret it as being the argument vector for the
command (with the first argument being the command to be
executed.)  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_command</span> <span class="o">=</span> <span class="n">command</span><span class="p">([</span><span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="s">&quot;/etc&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>If there are multiple arguments, each argument is taken as being
one element of the argument vector, with the first bring the
command to be executed.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_command</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="s">&quot;/etc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following keyword arguments may be given as options to a
command specification:</p>
<blockquote>
<dl class="docutils">
<dt><em>stderr</em></dt>
<dd>Filename (<a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str</span></tt></a>) or open <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#file"><tt class="xref docutils literal"><span class="pre">file</span></tt></a> object of
destination for stderr.</dd>
<dt><em>stderr_append</em></dt>
<dd><tt class="xref docutils literal"><span class="pre">True</span></tt> if <em>stderr</em> should be opened for append.  Does
nothing if <em>stderr</em> is already an open file.</dd>
<dt><em>ignore_exit_status</em></dt>
<dd>If <tt class="xref docutils literal"><span class="pre">True</span></tt>, then the exit status for this command is
completely ignored.</dd>
<dt><em>ignore_exit_statuses</em></dt>
<dd>A list of numeric exit statuses that should not be considered
errors when they are encountered.</dd>
</dl>
</blockquote>
<p>In addition, these options may be &#8220;handed down&#8221; from the
<a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a> call, or from <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> or
<a title="netsa.util.shell.run_collect" class="reference internal" href="#netsa.util.shell.run_collect"><tt class="xref docutils literal"><span class="pre">run_collect</span></tt></a>.  If so, then options given locally to the
command take precedence.</p>
<p>Example: Define a command spec using a single string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="s">&quot;ls -lR /tmp/foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: Define a command as the same as an old command with
different options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ignore_exit_status</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: Define a command using a list of strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">command</span><span class="p">([</span><span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="s">&quot;-lR&quot;</span><span class="p">,</span> <span class="s">&quot;/tmp/foo&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Example: Define a command using individual string arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="s">&quot;-lR&quot;</span><span class="p">,</span> <span class="s">&quot;/tmp/foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Short-hand Form:</strong></p>
<p>In the <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a>, <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a>, and
<a title="netsa.util.shell.run_collect" class="reference internal" href="#netsa.util.shell.run_collect"><tt class="xref docutils literal"><span class="pre">run_collect</span></tt></a> functions, commands may be given in a
short-hand form where convenient.  The short-hand form of a
command is a single string.  Here are some examples:</p>
<div class="highlight-python"><pre>"ls -lR"              =&gt;  command(["ls", "-lR"])
"echo test test a b"  =&gt;  command(["echo", "test", "test", "a", "b"])
"echo 'test test' a"  =&gt;  command(["echo", "test test", "a"])
"'weird program'"     =&gt;  command(["weird program"])</pre>
</div>
<p>There is no way to associate options with a short-hand
<a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a>.  If you wish to redirect error output or ignore
exit statuses, you will need to use the long form.</p>
<p><strong>Variable Expansion:</strong></p>
<p>When commands are executed, variable expansion is performed.  The
expansions are provided by the argument <cite>vars</cite> to
<a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> or <a title="netsa.util.shell.run_collect" class="reference internal" href="#netsa.util.shell.run_collect"><tt class="xref docutils literal"><span class="pre">run_collect</span></tt></a>.  Note that commands
are split into arguments <em>before</em> this expansion occurs, which is
a security measure.  This means that no matter what whitespace or
punctuation is in an expansion, it can&#8217;t change the sense of the
command.  The down side of that is that on occasions when you
would like to add multiple arguments to a command, you must
construct the <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> using the list syntax.</p>
<p>Expansion variable references are placed using the <a class="reference external" href="http://docs.python.org/library/stdtypes.html#string-formatting">Python String
formatting operations</a>.</p>
<p>Here is an example substitution, showing how <tt class="docutils literal"><span class="pre">%(target)s</span></tt>
becomes a single argument before the subsitution occurs.</p>
<div class="highlight-python"><pre>("ls -lR %(target)s", vars={'target': 'bl ah"'}) =&gt;
("ls", "-lR", "%(target)s", vars={'target': 'bl ah"'}) =&gt;
("ls", "-lR", 'bl ah "')</pre>
</div>
<p>If the value to be substituted implements the method
<tt class="docutils literal"><span class="pre">get_argument_list</span></tt>, which takes no arguments and returns a list
of strings, then those strings are included as multiple separate
arguments.  This is an expert technique for extending commands at
call-time for use internal to APIs.</p>
<div class="highlight-python"><pre>("ls -lR %(targets)s", vars={'targets': special_container}) =&gt;
("ls", "-lR", "target1", "target2", ...)</pre>
</div>
<p><strong>Functions as Commands:</strong></p>
<p>In addition to executable programs, Python functions may also be
used as commands.  This is useful if you wish to do processing of
data in a sub-process as part of a pipeline without needing to
have auxilliary Python script files.  However, this is an advanced
technique and you should fully understand the subtleties before
making use of it.</p>
<p>When a Python function is used as a command, the process will
<cite>fork</cite> as normal in preparation for executing a new command.
However, instead of <cite>exec</cite>-ing a new executable, the Python
function is called.  When the Python function completes (either
successfully or unsuccessfully), the child process exits
immediately.</p>
<p>If you intend to use this feature, be sure that you know how the
lifecycles of various objects will behave when the Python
interpreter is forked and two copies are running at once.</p>
<p>The command function is called with <em>vars</em> (as given to
<a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> or <a title="netsa.util.shell.run_collect" class="reference internal" href="#netsa.util.shell.run_collect"><tt class="xref docutils literal"><span class="pre">run_collect</span></tt></a>) as its first
argument, and the remainder of <em>argv</em> from calling <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a>
as its remaining arguments.</p>
</dd></dl>

<dl class="function">
<dt id="netsa.util.shell.pipeline">
<tt class="descclassname">netsa.util.shell.</tt><tt class="descname">pipeline</tt><big>(</big><em>&lt;pipeline spec&gt;</em><span class="optional">[</span>, <em>stdin : str or file</em>, <em>stdout : str or file</em>, <em>stdout_append=False</em>, <em>...</em><span class="optional">]</span><big>)</big> &rarr; pipeline<a class="headerlink" href="#netsa.util.shell.pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Interprets the arguments as a &#8220;pipeline specification&#8221;, and
returns that specification as a value.</p>
<p>If there is only a single argument and it is a <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a>,
then a new pipeline is returned with the options provided by this
call.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_pipeline</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">old_pipeline</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="s">&quot;/tmp/newfile&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is only a single argument and it is a <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#list"><tt class="xref docutils literal"><span class="pre">list</span></tt></a> or a
<a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#tuple"><tt class="xref docutils literal"><span class="pre">tuple</span></tt></a>, interpret it as being a list of commands and I/O
redirection short-hands to run in the pipeline.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_pipeline</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">([</span><span class="s">&quot;ls /etc&quot;</span><span class="p">,</span> <span class="s">&quot;tac&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>If there are multiple arguments, these arguments are treated as a
list of commands and I/O redirection short-hands (as if they were
passed as a single list.)  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_pipeline</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="s">&quot;ls /etc&quot;</span><span class="p">,</span> <span class="s">&quot;tac&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following keyword arguments may be given as options to a
pipeline specification:</p>
<blockquote>
<dl class="docutils">
<dt><em>stdin</em></dt>
<dd>Filename (<a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str</span></tt></a>) or open <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#file"><tt class="xref docutils literal"><span class="pre">file</span></tt></a> object of source
for stdin.</dd>
<dt><em>stdout</em></dt>
<dd>Filename (<a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str</span></tt></a>) or open <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#file"><tt class="xref docutils literal"><span class="pre">file</span></tt></a> object of
destination for stdout.</dd>
<dt><em>stdout_append</em></dt>
<dd><tt class="xref docutils literal"><span class="pre">True</span></tt> if <em>stdout</em> should be opened for append.  Does
nothing if <em>stdout</em> is already an open file.</dd>
</dl>
</blockquote>
<p>Because these options are so common, they may also be given in
short-hand form.  If the first command in the pipeline is a string
starting with <tt class="docutils literal"><span class="pre">&lt;</span></tt>, the remainder of the string is intepreted as
a filename for stdin.  If the last command in the pipeline is a
string starting with <tt class="docutils literal"><span class="pre">&gt;</span></tt> or <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>, the remainder of the string
is interpreted as a filename for stdout (and if <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> was used,
it is opened for append.)</p>
<p>In addition, any unrecognized keyword arguments will be provided
as defaults for any <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> specifications used in this
pipeline.  (So, for example, if you give the <em>ignore_exit_status</em>
option to <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a>, all of the commands in that pipeline will
use the same value of <em>ignore_exit_status</em> unless they have their
own overriding setting.)</p>
<p>Example: Define a pipeline using a list of commands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">command</span><span class="p">(</span><span class="s">&quot;ls -lR /tmp/foo&quot;</span><span class="p">),</span>
             <span class="n">command</span><span class="p">(</span><span class="s">&quot;sort&quot;</span><span class="p">),</span>
             <span class="n">stdout</span><span class="o">=</span><span class="s">&quot;/tmp/testout&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: Define the same pipeline using the short-hand form of
commands, and the shorthand method of setting stdout:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="s">&quot;ls -lR /tmp/foo&quot;</span><span class="p">,</span>
             <span class="s">&quot;sort&quot;</span><span class="p">,</span>
             <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: Define the same pipeline using a list instead of multiple
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">([</span><span class="s">&quot;ls -lR /tmp/foo&quot;</span><span class="p">,</span>
              <span class="s">&quot;sort&quot;</span><span class="p">,</span>
              <span class="s">&quot;&gt;/tmp/testout&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Example: Define a new pipeline which is the same as an old
pipeline but with different options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="s">&quot;/tmp/newout&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Short-hand Form:</strong></p>
<p>In the <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> command, pipelines may be given in a
short-hand form where convenient.  The short-hand form of a
pipeline is a list of commands and I/O redirection short-hands.
Here are some examples:</p>
<div class="highlight-python"><pre>["ls /tmp/die", "xargs rm"]  =&gt;  pipeline(["ls /tmp/die", "xargs rm"])
["&lt;/tmp/testin", "sort", "&gt;/tmp/testsort"]  =&gt;
         pipeline(["sort"], stdin="/tmp/testin", stdout="/tmp/testsort")</pre>
</div>
<p>Note that although you can set <em>stdin</em>, <em>stdout</em>, and
<em>stdout_append</em> using the short-hand form (by using the I/O
redirection strings at the start and end of the list), you cannot
set these options to open <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#file"><tt class="xref docutils literal"><span class="pre">file</span></tt></a> objects, only to
filenames.  You also set other options to be passed down to the
individual commands.</p>
<p><strong>Variable Expansion:</strong></p>
<p>As in <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a>, pipelines have variable expansion.  Most
variable expansion happens inside the actual commands in the
pipeline.  However, variable expansion also occurs in filenames
provided for the <em>stdin</em> and <em>stdout</em> options.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pipeline</span><span class="p">(</span><span class="s">&quot;ls -lR&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;</span><span class="si">%(output_file)s</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="p">(</span><span class="s">&quot;ls -lR&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%(output_file)s</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="running-pipelines">
<h2>Running Pipelines<a class="headerlink" href="#running-pipelines" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="netsa.util.shell.run_parallel">
<tt class="descclassname">netsa.util.shell.</tt><tt class="descname">run_parallel</tt><big>(</big><em>&lt;pipeline spec&gt;</em>, <em>...</em><span class="optional">[</span>, <em>vars : dict</em>, <em>...</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#netsa.util.shell.run_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a series of commands (as specified by the arguments provided)
by forking and establishing pipes between commands.  Raises
<a title="netsa.util.shell.PipelineException" class="reference internal" href="#netsa.util.shell.PipelineException"><tt class="xref docutils literal"><span class="pre">PipelineException</span></tt></a> and kills off all remaining subprocesses
if any one command fails.</p>
<p>Each argument is passed to the <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a> function to create
a new pipeline, which allows the short-hand form of pipelines (as
<a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/library/functions.html#list"><tt class="xref docutils literal"><span class="pre">list</span></tt></a> short-hands) to be used.</p>
<p>The following keyword arguments may be given as <em>options</em> to
<a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a>:</p>
<blockquote>
<dl class="docutils">
<dt><em>vars</em></dt>
<dd>A dictionary of variable substitutions to make in the
<a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> and <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a> specifications in this
<cite>run_parallel</cite> call.</dd>
</dl>
</blockquote>
<p>Additional keyword arguments will be passed down as default values
to the <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a> and <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> specifications making
up this <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> call.</p>
<p>The <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a> function returns the list of exit codes
of the processes in each pipeline as a list of lists. Each list
corresponds to a pipeline, in the order in which they were passed
into the function. Each element represents a process in the
pipeline, in the order they were defined in the pipeline. If a
process is not run (e.g., because a process preceding it in the
pipeline fails), the exit status will be <cite>None</cite>.</p>
<p>Example: Run three mkdirs in parallel and fail if any of them fails:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">run_parallel</span><span class="p">(</span><span class="s">&quot;mkdir a&quot;</span><span class="p">,</span> <span class="s">&quot;mkdir b&quot;</span><span class="p">,</span> <span class="s">&quot;mkdir c&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: Make a fifo, then afterwards, use it to do some work.
(Try making a typo in here and watch it kill everything off
instead of hanging forever.)</p>
<div class="highlight-python"><pre>run_parallel("mkfifo test.fifo")
run_parallel(["cat /etc/passwd", "sort -r", "cut -f1 -d:", "&gt;%(f)s"],
             ["cat %(f)s", "sed -e 's/a/b/g'", "&gt;%(f2)s"],
             vars={'f': 'test.fifo', 'f2': 'test.</pre>
</div>
<p>Example: run two pipelines in parallel, then investigate their
processes&#8217; exit statuses:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">exits</span> <span class="o">=</span> <span class="n">run_parallel</span><span class="p">([</span><span class="s">&quot;ls -l&quot;</span><span class="p">,</span> <span class="s">&quot;grep ^d&quot;</span><span class="p">],</span>
                     <span class="p">[</span><span class="s">&quot;cat /etc/passwd&quot;</span><span class="p">,</span> <span class="s">&quot;sort -r&quot;</span><span class="p">,</span> <span class="s">&quot;cut -f1 -d:&quot;</span><span class="p">])</span>
<span class="c"># If all complete successfully, exits will be:</span>
<span class="c">#  [[0, 0], [0, 0, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="netsa.util.shell.run_collect">
<tt class="descclassname">netsa.util.shell.</tt><tt class="descname">run_collect</tt><big>(</big><em>&lt;command spec&gt;</em>, <em>...</em><span class="optional">[</span>, <em>vars : dict</em>, <em>...</em><span class="optional">]</span><big>)</big> &rarr; str, str<a class="headerlink" href="#netsa.util.shell.run_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a series of commands specifying a single pipeline by forking
and establishing pipes between commands.  The output of the final
command is collected and returned in the result.  stderr across
all commands is returned in the result.  The final result is a
tuple (<cite>stdout</cite>, <cite>stderr</cite>)</p>
<p>Raises <a title="netsa.util.shell.PipelineException" class="reference internal" href="#netsa.util.shell.PipelineException"><tt class="xref docutils literal"><span class="pre">PipelineException</span></tt></a> and kills off all remaining
subprocesses if any one command fails.</p>
<p>The arguments are passed as arguments to a single call of the
<a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a> function to create a pipeline specification.
That is: each argument is a <a title="netsa.util.shell.command" class="reference internal" href="#netsa.util.shell.command"><tt class="xref docutils literal"><span class="pre">command</span></tt></a> specification.  Note
that this is not the same as <a title="netsa.util.shell.run_parallel" class="reference internal" href="#netsa.util.shell.run_parallel"><tt class="xref docutils literal"><span class="pre">run_parallel</span></tt></a>, which
interprets its arguments as multiple <a title="netsa.util.shell.pipeline" class="reference internal" href="#netsa.util.shell.pipeline"><tt class="xref docutils literal"><span class="pre">pipeline</span></tt></a>
specifications.</p>
<p>You can also redirect stderr independently for each command if
needed, allowing you to send some stderr to <tt class="docutils literal"><span class="pre">/dev/null</span></tt> or
another destination instead of collecting it.</p>
<p>Example: Reverse sort the output of <tt class="docutils literal"><span class="pre">ls</span> <span class="pre">-1</span></tt> and store the output
and error in the variables <cite>a_stdout</cite> and <cite>a_stderr</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Reverse sort the output of ls -1 and store the output in a</span>
<span class="p">(</span><span class="n">a_stdout</span><span class="p">,</span> <span class="n">a_stderr</span><span class="p">)</span> <span class="o">=</span> <span class="n">run_collect</span><span class="p">(</span><span class="s">&quot;ls -1&quot;</span><span class="p">,</span> <span class="s">&quot;sort -r&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: Do the same as the above, but run <tt class="docutils literal"><span class="pre">ls</span> <span class="pre">-1</span></tt> on a named
directory instead of the current working directory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The same with a named directory</span>
<span class="p">(</span><span class="n">b_stdout</span><span class="p">,</span> <span class="n">b_stderr</span><span class="p">)</span> <span class="o">=</span> <span class="n">run_collect</span><span class="p">(</span><span class="s">&quot;ls -1 </span><span class="si">%(dir)s</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;sort -r&quot;</span><span class="p">,</span>
                                   <span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;dir&#39;</span><span class="p">:</span> <span class="s">&#39;some_directory&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>Example: The following <em>does not collect output</em>, but instead
writes it to a file.  If there were any error output, it would be
returned in the variable <cite>c_stderr</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">empty_stdout</span><span class="p">,</span> <span class="n">c_stderr</span><span class="p">)</span> <span class="o">=</span> <span class="n">run_collect</span><span class="p">(</span><span class="s">&quot;ls -1&quot;</span><span class="p">,</span> <span class="s">&quot;sort -r&quot;</span><span class="p">,</span> <span class="s">&quot;&gt;test.out&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href=""><tt class="docutils literal"><span class="pre">netsa.util.shell</span></tt> &#8212; Robust Shell Pipelines</a><ul>
<li><a class="reference external" href="#overview">Overview</a></li>
<li><a class="reference external" href="#exceptions">Exceptions</a></li>
<li><a class="reference external" href="#building-commands-and-pipelines">Building Commands and Pipelines</a></li>
<li><a class="reference external" href="#running-pipelines">Running Pipelines</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="netsa_sql.html"
                                  title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">netsa.sql</span></tt> &#8212; SQL Database Access</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="netsa_data.html"
                                  title="next chapter">Data Manipulation</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/netsa_util_shell.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="netsa_data.html" title="Data Manipulation"
             >next</a> |</li>
        <li class="right" >
          <a href="netsa_sql.html" title="netsa.sql — SQL Database Access"
             >previous</a> |</li>
        <li><a href="index.html">NetSA Python v0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008-2010, Carnegie Mellon University.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.3.
    </div>
  </body>
</html>